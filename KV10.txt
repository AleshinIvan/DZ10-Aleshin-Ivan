#1
1) Описание типов наподобие вариантов 
2) Описание функторов (в этом случае перечень типов аргументов зависит от сигнатуры функции)
3) Классификация типов по заранее заданным множествам
В каждой такой задаче точное количество типов, передаваемых соответствующему шаблону в качестве аргументов, 
заранее определить сложно.
В таком случае вариативные шаблоны очень удобны в использовании.

#2
С помощью рекрсии: 
template<typename T, typename... Args> 
void foo(T value, Args... arg) {
 foo(arg...); 
}
int main() {
    foo(89.8, "HELLO", 5);
}
Шаблон работает так: первый аргумент — это обычный тип данных, а остальная часть — пакет. 
Тогда на каждом новом витке рекурсии из пакета будет вытащен первый аргумент, у него будет распознан тип, 
а остальной пакет будет пакетом из оставшихся аргументов.

#3
Можно испольщуя рекурсию из предыдущего вопроса вести подсчет ее запусков.

#4
1) Унарные - это выражения использующие стандартные операторы.
2) Бинарные - отличаются от унарных тем, что помимо пачки параметров и оператора свёртки, 
в выражении присутствует ещё один операнд, который не является пачкой параметров; 
т.е. обычный объект или выражение. 

#5
Статический полиморфизм: решение о том, какой метод выполнить, принимается во время компиляции. 
Примером этого может быть перегрузка метода. 
Динамический полиморфизм: решение о выборе метода для выполнения устанавливается во время выполнения. 
Примером этого может быть переопределение метода.